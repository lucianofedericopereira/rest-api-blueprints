# ADR 0005 — Cloud Infrastructure: AWS ECS Fargate + Terraform

**Status:** Accepted
**Date:** 2025-01-01
**Deciders:** Project maintainers

---

## Context

The REST API Blueprints project provides seven production-grade reference
implementations. To demonstrate how each stack is deployed in a real cloud
environment, the project needs an IaC (Infrastructure as Code) layer that:

- Deploys all seven stacks to a single cloud account without per-stack overhead
- Enforces the same ISO 27001 controls (A.9, A.10, A.12, A.14, A.17) that each
  application layer implements
- Is portable and readable by engineers unfamiliar with any specific tool or platform
- Does not require an active cloud account to review (i.e., the code itself
  serves as documentation)

---

## Decision

**Cloud provider:** AWS only (no multi-cloud for this reference layer)

**IaC tool:** Plain Terraform HCL (no CDK, Pulumi, or CloudFormation)

**Compute:** ECS Fargate (no Kubernetes, no EC2 fleet management)

**Module depth:** Full reference modules — one reusable module per concern,
composed in a single `environments/staging/` root module

---

## Module Structure

```
infra/terraform/
├── modules/
│   ├── vpc/          Networking baseline
│   ├── rds/          PostgreSQL (shared)
│   ├── elasticache/  Redis (shared)
│   ├── secrets/      Secrets Manager (per stack)
│   ├── ecr/          Container registry (per stack)
│   └── ecs-service/  Fargate service + IAM + logging + ALB (per stack)
└── environments/
    └── staging/      Root module: one call per stack × 7
```

---

## Alternatives Considered

### Alternative 1: AWS CDK (TypeScript)

**Pros:** Type-safe constructs, reusable as npm packages, testable with Jest
**Cons:** Adds a Node.js/TypeScript toolchain dependency; synthesised CloudFormation
is opaque; harder to read for engineers who know HCL but not CDK constructs.
CDK is an excellent choice for CDK-native teams but adds friction as a reference
implementation meant to be readable by anyone.

**Rejected because:** Plain HCL is more universally readable and requires fewer
toolchain dependencies.

### Alternative 2: Google Cloud Platform (Cloud Run + Terraform)

**Pros:** Cloud Run is arguably simpler than ECS for containerised workloads;
GCP IAM model is clean; Secret Manager is on par with AWS.
**Cons:** AWS is the dominant market-share provider; most readers will have AWS
exposure. Supporting both clouds doubles the IaC surface area without proportional
learning value for a reference project.

**Rejected because:** AWS was chosen for widest audience familiarity. A future
ADR may add a GCP layer.

### Alternative 3: Kubernetes (EKS / GKE)

**Pros:** Platform-agnostic; rich ecosystem; production standard at scale.
**Cons:** Adds significant operational complexity (control plane, node pools,
RBAC, ingress controllers, cert-manager, external-secrets-operator). The goal
here is to show ISO 27001 controls, not Kubernetes operations.

**Rejected because:** ECS Fargate achieves the same containerised deployment with
far less configuration surface, keeping the focus on security controls rather than
cluster management.

### Alternative 4: Pulumi (Python)

**Pros:** Real programming language; testable; familiar syntax for Python developers.
**Cons:** Less widely known than Terraform in the infrastructure community; requires
a Pulumi account for state management by default; state format is less transparent.

**Rejected because:** Terraform HCL has the largest community and tooling ecosystem
(fmt, docs, validate, tfsec, checkov, etc.), making it the best choice for a
reference implementation.

---

## Consequences

### Positive

- **Readable:** HCL is declarative and purpose-built for infrastructure — any
  engineer can read `main.tf` and understand what is provisioned.
- **Validatable without credentials:** `terraform init -backend=false` +
  `terraform validate` runs in CI without AWS credentials, catching syntax and
  type errors on every PR.
- **ISO 27001 controls enforced at the infrastructure layer:**
  - A.9: IAM task execution role grants only the minimum permissions needed
    (read own Secrets Manager secret, pull ECR image, write CloudWatch logs)
  - A.10: RDS encrypted at rest; ElastiCache encrypted in transit and at rest;
    all application secrets in Secrets Manager (never in `.tfvars` or task
    definition environment variables)
  - A.12: CloudWatch log groups with 365-day retention, one per stack
  - A.14: ECR with `scan_on_push = true` and `IMMUTABLE` image tags
  - A.17: RDS with 7-day backups and deletion protection; ElastiCache replication
    group with automatic failover
- **No secrets in state for application credentials:** Application secrets are
  provided as `sensitive` Terraform variables (never hardcoded); RDS master
  password and Redis auth token are generated by `random_password` resources and
  stored in Secrets Manager.
- **`for_each` over stacks:** All 7 ECS services, ECR repos, and Secrets Manager
  secrets are created with a single `for_each` expression, eliminating copy-paste
  drift between stacks.

### Negative / Trade-offs

- **Terraform state contains some sensitive data** (e.g., random password
  resource values). Mitigated by: S3 backend with encryption + DynamoDB locking;
  `.tfstate` files excluded from git via `infra/.gitignore`.
- **Bootstrap ordering:** RDS endpoint is not known until after the first apply.
  `DATABASE_URL` values in `terraform.tfvars` must be updated after the RDS
  module applies. A data-source-based approach or a two-stage apply can eliminate
  this but adds complexity beyond the scope of a reference blueprint.
- **Single region / single AZ (staging):** The staging environment uses 1 replica
  per service and 1 ElastiCache node to minimise cost. Production would set
  `num_cache_clusters = 2`, `desired_count = 2`, and `multi_az = true` on RDS.
- **No Terraform remote state sharing between modules:** Each module declares
  `required_providers` independently so it can be validated in isolation. This is
  intentional for a reference implementation; a real project would typically use
  a single root `required_providers` block.

---

## ISO 27001 Control Cross-Reference

| Control | Terraform Resource | File |
|---------|-------------------|------|
| A.9 | `aws_iam_role.task_execution` + `aws_iam_role_policy.read_secret` | `modules/ecs-service/main.tf` |
| A.9 | Security group rules (ALB→ECS, ECS→RDS, ECS→Redis) | `modules/vpc/main.tf` |
| A.10 | `aws_db_instance.this` (`storage_encrypted = true`) | `modules/rds/main.tf` |
| A.10 | `aws_elasticache_replication_group.this` (at-rest + in-transit encryption) | `modules/elasticache/main.tf` |
| A.10 | `aws_secretsmanager_secret` (application secrets, RDS password, Redis auth token) | `modules/secrets/main.tf`, `modules/rds/main.tf`, `modules/elasticache/main.tf` |
| A.10 | `secrets:` block in task definition (secrets never in `environment:`) | `modules/ecs-service/main.tf` |
| A.12 | `aws_cloudwatch_log_group.app` (`retention_in_days = 365`) | `modules/ecs-service/main.tf` |
| A.14 | `aws_ecr_repository.this` (`scan_on_push = true`, `IMMUTABLE` tags) | `modules/ecr/main.tf` |
| A.17 | `aws_db_instance.this` (`backup_retention_period = 7`, `deletion_protection = true`) | `modules/rds/main.tf` |
| A.17 | `aws_elasticache_replication_group.this` (`automatic_failover_enabled`) | `modules/elasticache/main.tf` |
| A.17 | `aws_ecs_service.app` (`deployment_minimum_healthy_percent = 50`) | `modules/ecs-service/main.tf` |
